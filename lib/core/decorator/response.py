import time,jsonfrom functools import wrapsfrom django.db import transactionfrom django.core.serializers.json import DjangoJSONEncoderfrom lib.core.http.response import HttpResponsefrom lib.core.paginator import Paginationfrom lib.utils.log import loggerfrom lib.utils.exceptions import PubErrorCustom,InnerErrorCustomfrom lib.utils.passwd import decrypt,encryptfrom lib.utils.db import RedisTokenHandlerfrom app.cache.utils import RedisCaCheHandlerclass Core_connector:    def __init__(self,**kwargs):        #是否加数据库事务        self.isTransaction = kwargs.get('isTransaction',False)        #是否分页        self.isPagination = kwargs.get('isPagination',False)        #是否加密        self.isPasswd = kwargs.get('isPasswd', False)        #是否校验ticket        self.isTicket = kwargs.get('isTicket', False)        #是否同步到缓存系统(如果同步到缓存系统,数据通过request.cache_save同步,isCach是数组)        self.isCache = kwargs.get("isCache",False)    #前置处理    def __request_validate(self,request,**kwargs):        #校验凭证并获取用户数据        if self.isTicket:            ticket = request.META.get('HTTP_TICKET')            if not ticket:                raise InnerErrorCustom(code="40001",msg="ticket不存在!")            result = RedisTokenHandler(key=ticket).redis_dict_get()            if not result:                raise InnerErrorCustom(code="40002",msg="ticket已失效!")            if result.get("status") == '1':                raise PubErrorCustom("账户已到期!")            elif result.get("status") == '2':                raise PubErrorCustom("账户已冻结!")            request.user = result        if self.isPasswd:            if request.method == 'GET':                if 'data' not in request.query_params:                    raise PubErrorCustom("请求报文有误!")                if request.query_params.get('data') and len(                    request.query_params.get('data')) and request.query_params.get('data') != '{}':                    request.query_params_format = json.loads(decrypt(request.query_params.get('data')))                else:                    request.query_params_format = {}            if request.method == 'POST':                if 'data' not in request.data:                    raise PubErrorCustom("请求报文有误!")                if request.data.get('data') and len(request.data.get('data')):                    request.data_format = json.loads(decrypt(request.data.get('data')))                else:                    request.data_format = {}        return kwargs    def __run(self,func,outside_self,request,*args, **kwargs):        if self.isTransaction:            with transaction.atomic():                res = func(outside_self, request, *args, **kwargs)        else:            res = func(outside_self, request, *args, **kwargs)        if res and 'data' in res and \            ((self.isPagination and isinstance(res['data'], list)) or (                self.isPagination and isinstance(res['data'], dict) and 'data' in res['data'])):            if 'header' in res:                header = res['header']                res = Pagination().get_paginated(data=res['data'], request=request)                res['header'] = {**res['header'], **header}            else:                res = Pagination().get_paginated(data=res['data'], request=request)        return HttpResponse(data=res)    #后置处理    def __response__validate(self,outside_self,func,response,request):        if self.isCache:            for cash_save_item in request.cache_save:                RedisCaCheHandler(**request.cash_save_item).run()        logger.info('[%s : %s]Training complete in %lf real seconds' % (outside_self.__class__.__name__, getattr(func, '__name__'), self.end - self.start))        return response    def __call__(self,func):        @wraps(func)        def wrapper(outside_self,request,*args, **kwargs):            try:                self.start = time.time()                kwargs=self.__request_validate(request,**kwargs)                response=self.__run(func,outside_self,request,*args, **kwargs)                self.end=time.time()                return self.__response__validate(outside_self,func,response,request)            except PubErrorCustom as e:                logger.error('[%s : %s  ] : [%s]'%(outside_self.__class__.__name__, getattr(func, '__name__'),e.msg))                return HttpResponse(data={"error":"error"})            except InnerErrorCustom as e:                logger.error('[%s : %s  ] : [%s]'%(outside_self.__class__.__name__, getattr(func, '__name__'),e.msg))                return HttpResponse(data={"error":"error"})            except Exception as e:                logger.error('[%s : %s  ] : [%s]'%(outside_self.__class__.__name__, getattr(func, '__name__'),str(e)))                return HttpResponse(data={"error":"error"})        return wrapper